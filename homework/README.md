### Pешение первой домашней работы sql
В качесте СУБД был использован postgresql. Я напоминаю здесь что здаю с опаздание и при проверке не забудьте про понижающий коэффициент 0.5;
ФИО: Арабчик Константин, login: light_qwant.

Ниже будет подбробно описаны предпосылки которые я использовал.

1. В задании я принял следующие предпосылки; 
- Первый id-шник это id департамента, равный id самого сотрудника.
- Второе число это номер начальника = номеру департамента в котором находится сотрудник
- Тоесть любой сотрудник, кроме первого,  находится в двух состояних: он глава какого-то отдела, если у него есть подчиненные, а также сотрудник другого.

На основании этих предположений добавления пользователя суводится просто к одной строчке в базе, валидация на этом этам не производится, кроме уникальности 
ключа сотрудника, он проверяется засчет установки primary_key

2. Из тех же предпосылок, что и в пункте один, смена отдела сотрудником является просто сменой записи его главы.

3. Этот запрос также простой, так как у всех непосредственных подчиненных указывается номер начальника, останется только сделать селект рассматривая только записи у
которых либо имеется искомый человек в качестве руководителя или это сам руководитель.

4. Для решения этого запроса я сразу нашел список всех не листовых вершин, после чего сделал LEFT JOIN исходных вершин с этим списком по id, после чего выбрал те,
у которых не было совпадений. 

5. Данный запрос первый, который потребовал RECURSE запрос. Идея заключается в обратном bfs-обходе, при котором мы на каждом шаге рекурсии находим предыдущую вершину с помощью select-запроса,
из-за небольшого моего недопонимания я реализовал два запроса, один включает в список начальников саму вершину с которой начинается рассмотрение предков.

6. Здесь идея была аналогична 5 заданию, только в обратную сторону.

7. В данном запросе первоначально присутствовала проблема наличия циклов в графе, но если рассмотреть структуру данных более подробно, то станет видно, что циклы могут быть только независими,
так как у любой вершины не более одного ребра, то очевидно в цикле оно будет частью цикла, но так как у нас связи в данных вида подчиненный->начальник, а также то что существует начальник без
других начальников, то получается из цикла должно быть ребро к остальному графу, связанному с главным начальником, а это значит что из какой-то вершины выходит два ребра, что в нашей схеме невохможно.

Тоесть необходимо в целом проверить только несколько простых свойств: 
- Наличие только одного начальника без начальника, или отсутствие сотрудников в целом.
- Отсутствие несколько компонент связности.
- Отсутствие двух начальников у одного сотрудника, но это проверяется с помощью promary key.

Последние два пункта достигаются с помощи проверки достижимости всех вершин в графе, а первый обычным select-ом.

8. Я реализовал два формата ранга, так как не понял про какой конкретно идет речь. Идея в целом такая же как у 6 задания.
Один ранг показывает сколько начальников над сотрудником, включая его, другой же показывается максимальное количество сотрудников ниже его.

9. Скорее всего этот запрос я сделал неправильно, я вывел все запросы в порядке подчинения как описано в условии, идея все такая же.

10. Здесь идея довольно простая, под путем будем понимать путь в нашем графе, если заменить ориентированные ребра на неориентированные. Иначе задача теряет смысл. Для решения построим 
цепочки вершин от корня нашего дерева, после чего сделаем две разности этих множеств, а также сделаем пересечение претков всех вершин в цепочке, там где они они пересекаются раньше 
всего находится минимальный общий предок. После чего мы обьеденяем полученные три множества в качестве результата.

Как проверять решение: 
В файле answers.sql приложени друг за другом 10 функций/процедур. 
Процедуры следует запускать следующим способом: 
- CALL procedure();
Функции же:
- SELECT * FROM function();

Перед началом использования необходимо запустить две процедуры:
CALL create_table();
Перед запуском load_table необходимо указать путь до своего файла с данными:
CALL load_table();

Далее в файле приложены ответы на задание по порядку.

